# Day 06 - Piscine SQL

## Задача
1. Давайте расширим нашу модель данных, включив в нее новую бизнес-функцию.
Каждый человек хочет получать персональную скидку, и каждая компания хочет быть ближе к клиентам.
Подумайте о персональных скидках для людей с одной стороны и пиццерий с другой. Необходимо создать новую реляционную таблицу (назовите ее `person_discounts`) со следующими правилами.
- установите атрибут id как первичный ключ (проверьте столбец id в существующих таблицах и выберите тот же тип данных);
- установите внешние ключи для атрибутов person_id и pizzeria_id для соответствующих таблиц (типы данных должны быть такими же, как и для столбцов id в соответствующих родительских таблицах);
- задайте явные имена для ограничений внешних ключей по шаблону fk_{table_name}_{column_name}, например, `fk_person_discounts_person_id`;
- добавьте атрибут discount для хранения значения скидки в процентах. Помните, что значение скидки может быть числом с плавающей точкой (используйте тип данных `numeric`). Поэтому, пожалуйста, выберите соответствующий тип данных, чтобы охватить эту возможность.
2. Фактически, мы создали структуру для хранения наших скидок и готовы пойти дальше и заполнить таблицу `person_discounts` новыми записями.
Итак, есть таблица `person_order`, в которой хранится история заказов клиента. Напишите оператор DML (`INSERT INTO ... SELECT ...`), который добавит новые записи в таблицу `person_discounts` на основе следующих правил.
- получить агрегированное состояние по столбцам person_id и pizzeria_id
- рассчитать размер персональной скидки с помощью следующего псевдокода:
    `if “amount of orders” = 1 then
        “discount” = 10.5 
    else if “amount of orders” = 2 then 
        “discount” = 22
    else 
        “discount” = 30`
- для генерации первичного ключа для таблицы `person_discounts` используйте SQL-конструкцию ниже (эта конструкция взята из раздела SQL «ОКОННЫЕ ФУНКЦИИ»).
`... ROW_NUMBER( ) OVER ( ) AS id ...`
3. Напишите оператор SQL, который возвращает заказы с фактической ценой и ценой с примененной скидкой для каждого человека в соответствующей пиццерии, а также сортирует по имени человека и названию пиццы.
4. Фактически, нам необходимо улучшить согласованность данных с одной стороны и производительность с другой. Создайте уникальный многостолбцовый индекс (с именем `idx_person_discounts_unique`), который предотвратит дубликаты парных значений идентификаторов персоны и пиццерии.
После создания нового индекса предоставьте любой простой SQL-оператор, подтверждающий использование индекса (с помощью `EXPLAIN ANALYZE`).
Пример «подтверждения» приведён ниже.
Index Scan using idx_person_discounts_unique on person_discounts
5. Добавьте следующие правила ограничений для существующих столбцов таблицы `person_discounts`.
- Столбец person_id не должен быть равен NULL (используйте ограничение `ch_nn_person_id`)
- Столбец pizzeria_id не должен быть равен NULL (используйте ограничение `ch_nn_pizzeria_id`)
- Столбец скидок не должен быть равен NULL (используйте ограничение `ch_nn_discount`)
- Столбец скидок по умолчанию должен быть равен 0 процентам
- Столбец скидок должен находиться в диапазоне значений от 0 до 100 (используйте ограничение `ch_range_discount`)
6. Для соответствия политикам управления данными необходимо добавить комментарии к таблице и её столбцам. Применим эту политику к таблице `person_discounts`. Добавьте комментарии на английском или русском языке (по вашему выбору), поясняющие бизнес-цель таблицы и все её атрибуты.
7. Давайте создадим последовательность базы данных с именем `seq_person_discounts` (начиная с 1 значения) и установим значение по умолчанию для атрибута id таблицы `person_discounts`, чтобы каждый раз автоматически брать значение из `seq_person_discounts`.
## Срок выполнения
Отведено: 1 день(8 часов).
Дополнительные задачи: отсутствуют.
Выполнено за 1 день.
## Тип проекта
Индивидуальный, весь проект выполнен мной.
## Используемые языки/технологии/библиотеки.
SQL, PostgreSQL.
