# Team 01 - Piscine SQL

## Задача
1. Давайте рассмотрим источники данных и первый логический уровень данных (ODS — Operational Data Store) в DWH.
Определение таблицы `User` (в исходной базе данных Green):
| Имя столбца | Описание |
| ------ | ------ |
| ID | Первичный ключ |
| name | Имя пользователя |
| lastname | Фамилия пользователя |
Определение таблицы 'Currency` (в исходной базе данных Red):
| Имя столбца | Описание |
| ------ | ------ |
| ID | Первичный ключ |
| name | Название валюты |
| rate_to_usd | Соотношение с долларом США |
Определение таблицы `Balance` (в исходной базе данных Blue):
| Имя столбца | Описание |
| ------ | ------ |
| user_id | «Виртуальный внешний ключ» к таблице «User» из другого источника |
| money | Сумма |
| type | Тип баланса (может быть 0, 1,...) |
| currency_id | «Виртуальный внешний ключ» к таблице «Current» из другого источника |
Зелёная, красная и синяя базы данных являются независимыми источниками данных и соответствуют шаблону микросервиса. Это означает высокий риск аномалий данных (см. ниже).
- Данные в таблицах не согласованы. Это означает, что есть пользователь, но нет строк в таблице «Balance», или наоборот, есть баланс, но нет строк в таблице «User». Аналогичная ситуация наблюдается между таблицами «Current» и «Balance» (другими словами, между ними нет явных внешних ключей).
- Возможны значения NULL для имени и фамилии в таблице «User».
- Все таблицы работают под SQL-трафиком OLTP (Online Transactional Processing). Это означает, что данные находятся в актуальном состоянии в один момент времени, исторические изменения не сохраняются для каждой таблицы.
Эти 3 перечисленные таблицы являются источниками данных для таблиц с аналогичными моделями данных в области DWH.
Определение таблицы `User` (в базе данных DWH):
| Имя столбца | Описание |
| ------ | ------ |
| ID | Первичный ключ |
| name | Имя пользователя |
| lastname | Фамилия пользователя |
Определение таблицы `Currency` (в базе данных DWH):
| Имя столбца | Описание |
| ------ | ------ |
| ID | Имитированный первичный ключ |
| name | Название валюты |
| rate_to_usd | Соотношение к доллару США |
| updated | Временная метка события из исходной базы данных |
`Имитированный первичный ключ` означает, что есть дубликаты с одинаковым ID, поскольку был добавлен новый обновленный атрибут, который преобразует нашу реляционную модель во временную реляционную модель.
Пожалуйста, ознакомьтесь с примером данных для валюты «EUR» ниже.
Этот пример основан на операторе SQL
SELECT *
FROM Currency
WHERE name = ‘EUR’
ORDER BY updated DESC;
| ID | name | rate_to_usd | updated |
| ------ | ------ | ------ | ------ |
| 100 | EUR | 0.9 | 03.03.2022 13:31 |
| 100 | EUR | 0.89 | 02.03.2022 12:31 |
| 100 | EUR | 0.87 | 02.03.2022 08:00 |
| 100 | EUR | 0.9 | 01.03.2022 15:36 |
| ... | ... | ... | ... |
Определение таблицы `Balance` (в базе данных DWH):
| Имя столбца | Описание |
| ------ | ------ |
| user_id | «Виртуальный внешний ключ» к таблице User из другого источника |
| money | Сумма |
| type | Тип баланса (может быть 0, 1,...) |
| currency_id | «Виртуальный внешний ключ» к таблице Currency из другого источника |
| updated | Временная метка события из исходной базы данных |
Взгляните на пример данных ниже.
Этот пример основан на SQL-запросе
SELECT *
FROM Balance
WHERE user_id = 103
ORDER BY type, updated DESC;
| user_id | money | type | currency_id | updated |
| ------ | ------ | ------ | ------ | ------ |
| 103 | 200 | 0 | 100 | 03.03.2022 12:31 |
| 103 | 150 | 0 | 100 | 02.03.2022 11:29 |
| 103 | 15 | 0 | 100 | 03.03.2022 08:00 |
| 103 | -100 | 1 | 102 | 01.03.2022 15:36 |
| 103 | 2000 | 1 | 102 | 12.12.2021 15:36 |
| ... | ... | ... | ... |... |
Все таблицы в DWH также наследуют все аномалии из исходных таблиц.
- Данные в таблицах не согласованы.
- Возможны значения NULL для имени и фамилии в таблице «Пользователь».
Напишите SQL-запрос, который возвращает общий объём (сумму всех денежных средств) транзакций с баланса пользователя, агрегированный по пользователю и типу баланса. Обратите внимание, что все данные должны быть обработаны, включая данные с отклонениями. Ниже представлена ​​таблица столбцов результата и соответствующая формула расчёта.
| Выходной столбец | Формула (псевдокод) |
| ------ | ------ |
| имя | источник: user.name, если user.name равно NULL, то вернуть значение `not defined` |
| фамилия | источник: user.lastname, если user.lastname равно NULL, то вернуть значение `not defined` |
| тип | источник: balance.type |
| объём | источник: balance.money, необходимо суммировать все движения денежных средств |
| название_валюты | источник: currency.name, если currency.name равно NULL, то вернуть значение `not defined` |
| last_rate_to_usd | источник: currency.rate_to_usd. берётся последний currency.rate_to_usd для соответствующей валюты, если currency.rate_to_usd равно NULL, то вернуть 1 |
| total_volume_in_usd | Источник: объем, last_rate_to_usd. Умножьте объем на last_rate_to_usd |
Взгляните на пример выходных данных ниже. Отсортируйте результат по имени пользователя в порядке убывания, а затем по фамилии пользователя и типу баланса в порядке возрастания.
| имя | фамилия | тип | объем |имя_валюты | last_rate_to_usd | total_volume_in_usd |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| Петр | не определено | 2 | 203 | не определено | 1 | 203 |
| Иван | Иванов | 1 | 410 | евро | 0,9 | 369 |
| ... | ... | ... | ... | ... | ... | ... |
2. Прежде чем углубляться в эту задачу, примените операторы INSERT ниже.
`insert into currency values ​​​​(100, 'EUR', 0.85, '2022-01-01 13:29');`
`insert into currency values ​​​​(100, 'EUR', 0.79, '2022-01-08 13:29');`
Напишите SQL-оператор, который возвращает всех пользователей, все транзакции Balance (в этой задаче проигнорируйте валюты, для которых нет ключа в таблице `Currency`) с названием валюты и расчётным значением валюты в долларах США на ближайший день.
Ниже представлена ​​таблица столбцов результата и соответствующая формула расчёта.
| Выходной столбец | Формула (псевдокод) |
| ------ | ------ |
| имя | Источник: имя_пользователя, если имя_пользователя равно NULL, то вернуть значение `not defined` |
| фамилия | Источник: имя_пользователя, если имя_пользователя равно NULL, то вернуть значение `not defined` |
| имя_валюты | Источник: имя_валюты |
| валюта_в_долларах | Использованные источники: курс_валюты к_доллару, курс_обновлен, курс_обновлен. Посмотрите на графическую интерпретацию формулы ниже. |
- Необходимо найти ближайший курс_к_доллару для валюты в прошлом (t1).
- Если t1 пусто (то есть курсов в прошлом нет), то найти ближайший курс_к_доллару для валюты в будущем (t2).
- Используйте курс t1 ИЛИ t2 для расчета валюты в формате USD.
Пожалуйста, посмотрите на пример выходных данных ниже. Сортируйте результат по имени пользователя в порядке убывания, а затем по фамилии пользователя и названию валюты в порядке возрастания.
| name | lastname | currency_name | currency_in_usd |
| ------ | ------ | ------ | ------ |
| Иван | Иванов | EUR | 150.1 |
| Иван | Иванов | EUR | 17 |
| ... | ... | ... | ... |
## Срок выполнения
Отведено: 2 дня(10 часов).
Дополнительные задачи: отсутствуют.
Выполнено за 2 дня.
## Тип проекта
Групповой(полученная позиция - тимлид). Имплементировал половину задач.
## Используемые языки/технологии/библиотеки.
SQL, PostgreSQL.
