# Day 09 - Piscine SQL

## Задача
1. Мы хотим быть более надёжными в работе с данными и не терять ни одного события об изменениях. Давайте реализуем функцию аудита для входящих изменений INSERT.
Создайте таблицу `person_audit` с той же структурой, что и таблица person, но добавьте несколько дополнительных изменений. Взгляните на таблицу ниже с описаниями каждого столбца.
| Column | Type | Description |
| ------ | ------ | ------ |
| created | timestamp with time zone | timestamp when a new event has been created.  Default value is a current timestamp and NOT NULL |
| type_event | char(1) | possible values I (insert), D (delete), U (update). Default value is ‘I’. NOT NULL. Add check constraint `ch_type_event` with possible values ‘I’, ‘U’ and ‘D’ |
| row_id |bigint | copy of person.id. NOT NULL |
| name |varchar | copy of person.name (no any constraints) |
| age |integer | copy of person.age (no any constraints) |
| gender |varchar | copy of person.gender (no any constraints) |
| address |varchar | copy of person.address (no any constraints) |
Давайте создадим функцию триггера базы данных с именем `fnc_trg_person_insert_audit`, которая должна обрабатывать DML-трафик `INSERT` и копировать новую строку в таблицу person_audit.
Подсказка: если вы хотите реализовать триггер PostgreSQL (подробнее см. в документации PostgreSQL), вам нужно создать два объекта: функцию триггера базы данных и триггер базы данных.
Итак, пожалуйста, определите триггер базы данных с именем `trg_person_insert_audit` со следующими параметрами:
- триггер с опцией «FOR EACH ROW» (для каждой строки);
- триггер с опцией «AFTER INSERT» (после вставки);
- триггер вызывает функцию триггера fnc_trg_person_insert_audit.
Когда вы закончите с объектами триггера, выполните оператор `INSERT` в таблице person.
`INSERT INTO person(id, name, age, gender, address) VALUES (10,'Damir', 22, 'male', 'Irkutsk');`
2. Продолжим реализацию нашего шаблона аудита для таблицы person. Просто определите триггер `trg_person_update_audit` и соответствующую функцию триггера `fnc_trg_person_update_audit` для обработки всего трафика `UPDATE` в таблице person. Необходимо сохранить старые состояния всех значений атрибутов.
Когда будете готовы, примените операторы UPDATE ниже.
`UPDATE person SET name = 'Bulat' WHERE id = 10;`
`UPDATE person SET name = 'Damir' WHERE id = 10;`
3. Наконец, нам нужно обработать операторы `DELETE` и создать копию СТАРЫХ состояний для всех значений атрибутов. Создайте триггер `trg_person_delete_audit` и соответствующую функцию триггера `fnc_trg_person_delete_audit`.
Когда будете готовы, примените SQL-оператор ниже.
`DELETE FROM person WHERE id = 10;`
4. На самом деле, для одной таблицы `person` существует 3 триггера. Давайте объединим всю нашу логику в один основной триггер с именем `trg_person_audit` и новую соответствующую функцию триггера `fnc_trg_person_audit`.
Другими словами, весь трафик DML (`INSERT`, `UPDATE`, `DELETE`) должен обрабатываться из одного функционального блока. Пожалуйста, явно определите отдельный блок IF-ELSE для каждого события (I, U, D)!
Кроме того, выполните следующие действия.
- чтобы удалить 3 старых триггера из таблицы `person`.
- чтобы удалить 3 старых функции триггера.
- чтобы выполнить `TRUNCATE` (или `DELETE`) для всех строк в нашей таблице `person_audit`.
Когда будете готовы, пожалуйста, повторно примените набор операторов DML. 
`INSERT INTO person(id, name, age, gender, address)  VALUES (10,'Damir', 22, 'male', 'Irkutsk');`
`UPDATE person SET name = 'Bulat' WHERE id = 10;`
`UPDATE person SET name = 'Damir' WHERE id = 10;`
`DELETE FROM person WHERE id = 10;`
5. Как вы помните, мы создали два представления базы данных для разделения данных из таблиц с данными о персонах по признаку пола.
Определите две SQL-функции (обратите внимание, это не функции pl/pgsql) с именами:
- `fnc_persons_female` (должна возвращать лиц женского пола);
- `fnc_persons_male` (должна возвращать лиц мужского пола);
Чтобы проверить себя и вызвать функцию, вы можете использовать следующий оператор (удивительно! с функцией можно работать как с виртуальной таблицей!).
SELECT *
FROM fnc_persons_male();
SELECT *
FROM fnc_persons_female();
6. Похоже, две функции из упражнения 04 требуют более общего подхода. Пожалуйста, перед дальнейшими действиями удалите эти функции из базы данных.
Напишите обычную SQL-функцию (обратите внимание, не pl/pgsql-функцию) с именем `fnc_persons`. Эта функция должна иметь параметр `IN` pgender со значением по умолчанию = `female`.
Чтобы проверить себя и вызвать функцию, вы можете использовать следующий оператор (вау! С функцией можно работать как с виртуальной таблицей, но с большей гибкостью!).
    select *
    from fnc_persons(pgender := 'male');
    select *
    from fnc_persons();
7. Давайте рассмотрим функции pl/pgsql прямо сейчас.
Пожалуйста, создайте функцию pl/pgsql `fnc_person_visits_and_eats_on_date` на основе SQL-запроса, которая находит названия пиццерий, которые посетил человек (параметр `IN` pperson со значением по умолчанию `Дмитрий`) и где он мог купить пиццу дешевле указанной суммы в рублях (параметр `IN` pprice со значением по умолчанию `500`) в указанную дату (параметр `IN` pdate со значением по умолчанию `8 января 2022 года`).
Чтобы проверить себя и вызвать функцию, вы можете создать следующий оператор.
    select *
    from fnc_person_visits_and_eats_on_date(pprice := 800);
    select *
    from fnc_person_visits_and_eats_on_date(pperson := 'Anna',pprice := 1300,pdate := '2022-01-01');
8. Напишите функцию `func_minimum` на SQL или PL/PGSQL (на ваше усмотрение), входным параметром которой является массив чисел, и которая должна возвращать минимальное значение.
Чтобы проверить себя и вызвать функцию, вы можете использовать следующий оператор.
SELECT func_minimum(VARIADIC arr => ARRAY[10.0, -1.0, 5.0, 4.4]);
9. Напишите функцию `fnc_fibonacci` на SQL или PL/PGSQL (на ваше усмотрение), которая принимает входной параметр pstop с целочисленным типом (по умолчанию 10). Выход функции — таблица со всеми числами Фибоначчи, меньшими pstop.
Чтобы проверить себя и вызвать функцию, вы можете использовать следующий оператор.
    select * from fnc_fibonacci(100);
    select * from fnc_fibonacci();
## Срок выполнения
Отведено: 1 день(8 часов).
Дополнительные задачи: отсутствуют.
Выполнено за 1 день.
## Тип проекта
Индивидуальный, весь проект выполнен мной.
## Используемые языки/технологии/библиотеки.
SQL, PostgreSQL.
